name: CI

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # =========================
  # Job 1: App (Next) en contenedor Node + Alpine
  # =========================
  build-and-test:
    runs-on: ubuntu-latest
    container:
      image: node:20-alpine
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare Alpine
        run: |
          apk add --no-cache libc6-compat git
          corepack enable

      - name: Cache npm
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-npm-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-npm-

      - name: Cache Next build
        uses: actions/cache@v4
        with:
          path: .next/cache
          key: ${{ runner.os }}-next-${{ hashFiles('**/package-lock.json', '**/next.config.*') }}
          restore-keys: |
            ${{ runner.os }}-next-

      - name: Install dependencies
        run: npm ci

      - name: Disable Next telemetry
        run: npx next telemetry disable || true

      - name: Lint
        run: npm run lint

      - name: Typecheck
        run: npm run typecheck

      - name: Build
        run: npm run build

      - name: Test (CI + Coverage)
        env:
          CI: "true"
        run: npm run test:ci

      - name: Upload coverage artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ github.sha }}
          path: coverage
          if-no-files-found: warn

  # =========================
  # Job 2: DB tests en contenedor Node + Alpine + service Postgres
  # =========================
  db-tests:
    name: DB (smoke tests)
    runs-on: ubuntu-latest
    container:
      image: node:20-alpine
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: catalogo_test
        ports: [ "5432:5432" ]
        options: >-
          --health-cmd="pg_isready -U postgres -d catalogo_test"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=20

    steps:
      - uses: actions/checkout@v4

      - name: psql client
        shell: sh
        run: apk add --no-cache postgresql-client

      - name: Wait for DB
        shell: sh
        env: { PGURL: postgresql://postgres:postgres@postgres:5432/catalogo_test }
        run: |
          until psql "$PGURL" -c "select 1" >/dev/null 2>&1; do echo "⏳ waiting db..."; sleep 1; done
          echo "✅ DB up"

      - name: Supabase shims + extensions
        shell: sh
        env: { PGURL: postgresql://postgres:postgres@postgres:5432/catalogo_test }
        run: |
          psql "$PGURL" -v ON_ERROR_STOP=1 <<'SQL'
          create extension if not exists pgcrypto;
          create extension if not exists unaccent;
          create extension if not exists pg_trgm;

          create schema if not exists auth;
          create table  if not exists auth.users (id uuid primary key default gen_random_uuid());

          create schema if not exists app;
          create or replace function app.set_uid(uid uuid)
          returns void language plpgsql as $$
          begin
            -- is_local = FALSE => persiste en la sesión (evita timeouts raros)
            perform set_config('app.uid', coalesce(uid::text,''), false);
          end $$;

          create or replace function auth.uid()
          returns uuid language sql stable as $$
          select nullif(current_setting('app.uid', true), '')::uuid $$;
          SQL

      - name: Apply schema / rls / seeds
        shell: sh
        env: { PGURL: postgresql://postgres:postgres@postgres:5432/catalogo_test }
        run: |
          DB_DIR="app-v1/catalogo/db"; [ -f "$DB_DIR/schema.sql" ] || DB_DIR="catalogo/db"
          psql "$PGURL" -v ON_ERROR_STOP=1 -f "$DB_DIR/schema.sql"
          psql "$PGURL" -v ON_ERROR_STOP=1 -f "$DB_DIR/rls.sql"
          psql "$PGURL" -v ON_ERROR_STOP=1 -f "$DB_DIR/seeds.sql"

      - name: Create role "app" + mínimos grants
        shell: sh
        env:
          PGURL: postgresql://postgres:postgres@postgres:5432/catalogo_test
        run: |
          psql "$PGURL" -v ON_ERROR_STOP=1 <<'SQL'
          do $$ begin
            if not exists (select 1 from pg_roles where rolname = 'app') then
              create role app login password 'app';
            end if;
          end $$;

          -- USAGE en esquemas necesarios (RLS usa auth.uid())
          grant usage on schema public, app, auth to app;

          -- Permisos básicos en public (RLS decidirá si deja escribir)
          grant select, insert, update, delete on all tables in schema public to app;
          grant usage, select on all sequences in schema public to app;

          -- Permitir ejecutar funciones usadas por los tests/policies
          grant execute on function app.set_uid(uuid) to app;
          grant execute on function auth.uid() to app;
          SQL

          
      - name: Install deps & run smoke tests
        shell: sh
        run: |
          APP_DIR="app-v1"; [ -f "$APP_DIR/package.json" ] || APP_DIR="."
          cd "$APP_DIR"
          npm ci
          npm i -D pg
          npm run test:db
        env:
          DATABASE_URL: postgresql://app:app@postgres:5432/catalogo_test
