name: CI

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# =========================
# Job 1: App (Next) en contenedor Node + Alpine
# =========================
jobs:
  build-and-test:
    runs-on: ubuntu-latest
    container:
      image: node:20-alpine
    defaults:
      run:
        shell: sh
        working-directory: app-v1
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare Alpine
        run: |
          apk add --no-cache libc6-compat git bash
          corepack enable

      # Cache de npm vía setup-node (más simple/fiable dentro de container)
      - name: Setup Node (cache npm)
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: app-v1/package-lock.json

      # Cache de Next (opcional). RUTA desde la raíz del repo:
      - name: Cache Next build
        uses: actions/cache@v4
        with:
          path: app-v1/.next/cache
          key: ${{ runner.os }}-next-${{ hashFiles('app-v1/package-lock.json', 'app-v1/next.config.*') }}
          restore-keys: |
            ${{ runner.os }}-next-

      - name: Install dependencies
        run: npm ci

      - name: Disable Next telemetry
        run: npx next telemetry disable || true

      - name: Lint
        run: npm run lint

      - name: Typecheck
        run: npm run typecheck || true

      - name: Build
        run: npm run build

      - name: Test (CI + Coverage)
        env:
          CI: "true"
        run: npm run test:ci

      - name: Upload coverage artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ github.sha }}
          path: app-v1/coverage
          if-no-files-found: warn

  # =========================
  # Job 2: DB tests en contenedor Node + Alpine + service Postgres
  # =========================
  db-tests:
    runs-on: ubuntu-latest
    container:
      image: node:20-alpine
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: catalogo_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready -U postgres -d catalogo_test"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=20
    defaults:
      run:
        shell: sh
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare Alpine (psql + bash opcional)
        run: |
          apk add --no-cache postgresql-client bash

      - name: Wait for DB
        env:
          PGURL: postgresql://postgres:postgres@postgres:5432/catalogo_test
        run: |
          until psql "$PGURL" -c "select 1" >/dev/null 2>&1; do echo "⏳ waiting db..."; sleep 1; done
          echo "✅ DB up"

      - name: Prepare extensions + Supabase shims
        env:
          PGURL: postgresql://postgres:postgres@postgres:5432/catalogo_test
        run: |
          psql "$PGURL" -v ON_ERROR_STOP=1 <<'SQL'
          create extension if not exists pgcrypto;
          create extension if not exists unaccent;
          create extension if not exists pg_trgm;

          create schema if not exists auth;
          create table  if not exists auth.users (id uuid primary key default gen_random_uuid());

          create schema if not exists app;
          create or replace function app.set_uid(uid uuid)
          returns void language plpgsql as $$
          begin perform set_config('app.uid', coalesce(uid::text,''), true); end $$;

          create or replace function auth.uid()
          returns uuid language sql stable as $$
          select nullif(current_setting('app.uid', true), '')::uuid $$;
          SQL

      - name: Apply schema / rls / seeds
        working-directory: app-v1
        env:
          PGURL: postgresql://postgres:postgres@postgres:5432/catalogo_test
        run: |
          psql "$PGURL" -v ON_ERROR_STOP=1 -f catalogo/db/schema.sql
          psql "$PGURL" -v ON_ERROR_STOP=1 -f catalogo/db/rls.sql
          psql "$PGURL" -v ON_ERROR_STOP=1 -f catalogo/db/seeds.sql

      - name: Create non-superuser role for RLS tests
        env:
          PGURL: postgresql://postgres:postgres@postgres:5432/catalogo_test
        run: |
          psql "$PGURL" -v ON_ERROR_STOP=1 <<'SQL'
          do $$ begin
            if not exists (select 1 from pg_roles where rolname='app') then
              create role app login password 'app';
            end if;
          end $$;

          grant usage on schema public to app;
          grant select, insert, update, delete on all tables in schema public to app;
          grant usage, select on all sequences in schema public to app;
          alter default privileges in schema public grant select, insert, update, delete on tables to app;
          alter default privileges in schema public grant usage, select on sequences to app;
          SQL

      - name: Setup Node (cache npm)
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: app-v1/package-lock.json

      - name: Install deps and run DB tests
        working-directory: app-v1
        env:
          DATABASE_URL: postgresql://app:app@postgres:5432/catalogo_test
        run: |
          npm ci
          npm i -D pg
          npm pkg set scripts.test:db="vitest run --reporter=dot --dir tests/db"
          npm run test:db
