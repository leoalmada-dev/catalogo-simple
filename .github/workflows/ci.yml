name: CI

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: ci-${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # =========================
  # Job 1: App (Next) en contenedor Node + Alpine
  # =========================
  build-and-test:
    runs-on: ubuntu-latest
    container:
      image: node:20-alpine
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect APP_DIR (app-v1 ó raíz)
        shell: sh
        run: |
          if [ -f app-v1/package.json ]; then
            echo "APP_DIR=app-v1" >> $GITHUB_ENV
          else
            echo "APP_DIR=." >> $GITHUB_ENV
          fi
          echo "APP_DIR=$APP_DIR"

      - name: Prepare Alpine
        shell: sh
        run: |
          apk add --no-cache libc6-compat git
          corepack enable

      - name: Setup Node (cache npm)
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: ${{ env.APP_DIR }}/package-lock.json

      # (Opcional) Cache de Next: solo si existe .next/cache
      - name: Cache Next build
        if: ${{ hashFiles(format('{0}/package-lock.json', env.APP_DIR)) != '' }}
        uses: actions/cache@v4
        with:
          path: ${{ env.APP_DIR }}/.next/cache
          key: ${{ runner.os }}-next-${{ hashFiles(format('{0}/package-lock.json', env.APP_DIR), format('{0}/next.config.*', env.APP_DIR)) }}
          restore-keys: |
            ${{ runner.os }}-next-

      - name: Install dependencies
        shell: sh
        working-directory: ${{ env.APP_DIR }}
        run: npm ci

      - name: Disable Next telemetry
        shell: sh
        working-directory: ${{ env.APP_DIR }}
        run: npx next telemetry disable || true

      - name: Lint
        shell: sh
        working-directory: ${{ env.APP_DIR }}
        run: npm run lint

      - name: Typecheck
        shell: sh
        working-directory: ${{ env.APP_DIR }}
        run: npm run typecheck || true

      - name: Build
        shell: sh
        working-directory: ${{ env.APP_DIR }}
        run: npm run build

      - name: Test (CI + Coverage)
        shell: sh
        working-directory: ${{ env.APP_DIR }}
        env:
          CI: "true"
        run: npm run test:ci

      - name: Upload coverage artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ github.sha }}
          path: ${{ env.APP_DIR }}/coverage
          if-no-files-found: warn

  # =========================
  # Job 2: DB tests en contenedor Node + Alpine + service Postgres
  # =========================
  db-tests:
    runs-on: ubuntu-latest
    container:
      image: node:20-alpine
    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: catalogo_test
        ports: [ "5432:5432" ]
        options: >-
          --health-cmd="pg_isready -U postgres -d catalogo_test"
          --health-interval=5s
          --health-timeout=5s
          --health-retries=20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect APP_DIR y DB_DIR
        shell: sh
        run: |
          if [ -f app-v1/package.json ]; then
            echo "APP_DIR=app-v1" >> $GITHUB_ENV
          else
            echo "APP_DIR=." >> $GITHUB_ENV
          fi
          if [ -f app-v1/catalogo/db/schema.sql ]; then
            echo "DB_DIR=app-v1/catalogo/db" >> $GITHUB_ENV
          elif [ -f catalogo/db/schema.sql ]; then
            echo "DB_DIR=catalogo/db" >> $GITHUB_ENV
          else
            echo "❌ No se encontró catalogo/db/schema.sql"; exit 1
          fi
          echo "APP_DIR=$APP_DIR  DB_DIR=$DB_DIR"

      - name: Install psql client (Alpine)
        shell: sh
        run: apk add --no-cache postgresql-client

      - name: Wait for DB
        shell: sh
        env:
          PGURL: postgresql://postgres:postgres@postgres:5432/catalogo_test
        run: |
          until psql "$PGURL" -c "select 1" >/dev/null 2>&1; do echo "⏳ waiting db..."; sleep 1; done
          echo "✅ DB up"

      - name: Prepare extensions + Supabase shims
        shell: sh
        env:
          PGURL: postgresql://postgres:postgres@postgres:5432/catalogo_test
        run: |
          psql "$PGURL" -v ON_ERROR_STOP=1 <<'SQL'
          create extension if not exists pgcrypto;
          create extension if not exists unaccent;
          create extension if not exists pg_trgm;

          create schema if not exists auth;
          create table  if not exists auth.users (id uuid primary key default gen_random_uuid());

          create schema if not exists app;
          create or replace function app.set_uid(uid uuid)
          returns void language plpgsql as $$
          begin perform set_config('app.uid', coalesce(uid::text,''), true); end $$;

          create or replace function auth.uid()
          returns uuid language sql stable as $$
          select nullif(current_setting('app.uid', true), '')::uuid $$;
          SQL

      - name: Apply schema / rls / seeds
        shell: sh
        env:
          PGURL: postgresql://postgres:postgres@postgres:5432/catalogo_test
        run: |
          psql "$PGURL" -v ON_ERROR_STOP=1 -f "$DB_DIR/schema.sql"
          psql "$PGURL" -v ON_ERROR_STOP=1 -f "$DB_DIR/rls.sql"
          psql "$PGURL" -v ON_ERROR_STOP=1 -f "$DB_DIR/seeds.sql"

      - name: Create non-superuser role for RLS tests
        shell: sh
        env:
          PGURL: postgresql://postgres:postgres@postgres:5432/catalogo_test
        run: |
          psql "$PGURL" -v ON_ERROR_STOP=1 <<'SQL'
          do $$ begin
            if not exists (select 1 from pg_roles where rolname='app') then
              create role app login password 'app';
            end if;
          end $$;

          grant usage on schema public to app;
          grant select, insert, update, delete on all tables in schema public to app;
          grant usage, select on all sequences in schema public to app;
          alter default privileges in schema public grant select, insert, update, delete on tables to app;
          alter default privileges in schema public grant usage, select on sequences to app;
          SQL

      - name: Setup Node (cache npm)
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm
          cache-dependency-path: ${{ env.APP_DIR }}/package-lock.json

      - name: Install deps and run DB tests (Vitest)
        shell: sh
        working-directory: ${{ env.APP_DIR }}
        env:
          DATABASE_URL: postgresql://app:app@postgres:5432/catalogo_test
        run: |
          npm ci
          npm i -D pg
          npm pkg set scripts.test:db="vitest run --reporter=dot --dir tests/db"
          npm run test:db
